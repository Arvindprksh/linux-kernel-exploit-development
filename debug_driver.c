#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>
#include <linux/slab.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "debug_driver_device"
#define CLASS_NAME "debug_driver_class"
#define MESSAGE_LEN 16

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Keith Makan");
MODULE_DESCRIPTION("A simple example of an ioctl based char driver");
MODULE_VERSION("0.01");

static int majorNumber;
static char *message;
static int open_count = 0;
static struct class *debug_driver_class;
static struct device *debug_driver_device; 

static int dev_open(struct inode *, struct file *);
static int dev_release(struct inode *, struct file *);
static ssize_t dev_read(struct file *, char *, size_t, loff_t *); 
static ssize_t dev_write(struct file *, const char *, size_t, loff_t *); 

static struct file_operations fops = {
	.open = dev_open,
	.read = dev_read,
	.write = dev_write,
	.release = dev_release,
};

static int __init debug_driver_init(void) {
	printk(KERN_INFO "[debug_driver] loaded! \n");
	majorNumber = register_chrdev(0,DEVICE_NAME, &fops);
	if (majorNumber < 0){
		printk(KERN_ALERT "[debug_driver] problem registering device...\n");
		return majorNumber;
	}	
	printk(KERN_INFO "[debug_driver] device registered successfully\n");
	debug_driver_class = class_create(THIS_MODULE,CLASS_NAME);

	if (IS_ERR(debug_driver_class)){
		unregister_chrdev(majorNumber,DEVICE_NAME);
		printk(KERN_ALERT "[debug_driver] failed to register device\n");
		return PTR_ERR(debug_driver_class);
	}
	debug_driver_device = device_create(debug_driver_class,NULL,MKDEV(majorNumber,0), NULL, DEVICE_NAME);
	if (IS_ERR(debug_driver_device)){
		class_destroy(debug_driver_class);
		unregister_chrdev(majorNumber,DEVICE_NAME);
		printk(KERN_ALERT,"[debug_driver] failed to register device\n");
		return PTR_ERR(debug_driver_class);
	}
	printk(KERN_INFO "[debug_driver] device has been successfully created \n");
	message = (char*) kmalloc(sizeof(char)*MESSAGE_LEN,GFP_KERNEL);
	memset(message,0,sizeof(char)*MESSAGE_LEN);
		
	return 0;
}

static void __exit debug_driver_exit(void) {
	device_destroy(debug_driver_class,MKDEV(majorNumber,0));
	class_unregister(debug_driver_class);
	class_destroy(debug_driver_class);
	unregister_chrdev(majorNumber,DEVICE_NAME);
	kfree(message);
	printk(KERN_INFO "[debug_driver] unloaded and device destroyed...\n");
}

static int dev_open(struct inode * inode, struct file * filep){
	open_count++;
	return 0;	
}

static ssize_t dev_read(struct file * filep, char * buffer, size_t len, loff_t * offset){
	int error_count = 0;
	error_count = copy_to_user(buffer,message,len); //copy out of message into buffer

	if (error_count == 0){
		printk(KERN_INFO "[debug_driver] buffer copied to message holder\n");
		return len==0;
	}
	else{
		printk(KERN_ALERT "[debug_driver] buffer could not be copied\n");
		return -EFAULT;
	}
	
}

static ssize_t dev_write(struct file * filep, const char *buffer, size_t len, loff_t *offset){
	if (copy_from_user(message,buffer,len) == 0){ //no check to see if message is big enough
		printk(KERN_INFO "[debug_driver] message successfully copied message => [%s]", message);
		return strlen(message);	
	}else{
		printk(KERN_ALERT "[debug_driver] problem copying message...\n");
		return -EFAULT;
	}
}

static int dev_release(struct inode *inodep, struct file *filep){
	printk(KERN_INFO "[debug_driver] device released \n");
	return 0;	
}




module_init(debug_driver_init);
module_exit(debug_driver_exit);
